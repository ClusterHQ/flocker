# Copyright ClusterHQ Inc.  See LICENSE file for details.

"""
Utility functions for cluster lifecycle management in test env.
"""

from uuid import uuid4, UUID
from hashlib import sha1
from twisted.python.constants import Values, ValueConstant


class TestTypes(Values):
    """
    Supported test types.
    """
    FUNCTIONAL = ValueConstant(1)
    ACCEPTANCE = ValueConstant(2)


# Highly duplicative of other constants.  FLOC-2584.
class Providers(Values):
    """
    Supported storage providers.
    """
    UNSPECIFIED = ValueConstant(0)
    AWS = ValueConstant(1)
    OPENSTACK = ValueConstant(2)


def _hashable(values):
    """
    Create a stable string value frmo a ``Values`` subclass.
    """
    return "".join(sorted(list(
        "{} {}\n".format(constant.name, constant.value)
        for constant in values.iterconstants()
    )))


def _hash(data):
    """
    Compute a non-cryptography, unsigned 16 bit hash of a byte string.

    :param bytes data: The data to hash.
    :rtype: ``int``
    """
    return int(sha1(data).hexdigest(), 16) % (2 ** 16)


def get_version(*collections):
    """
    Get a stable version number for some ``Values`` subclasses.

    The version number will identify the collections and the names and values
    of their constants.
    """
    return _hash("".join(_hashable(values) for values in collections))


# A stable identifier derived from the values we're trying to encode into the
# identifier.  The version will change if the set of encodeable values changes.
VERSION = get_version(TestTypes, Providers)

# An even more stable identifier that never changes and that unambiguously
# marks a cluster identifier as having been generated by this function (except
# for random collisions, of course, so we use as many bits for this marker as
# we can while leaving room for some randomness and the version number).
#
# Arbitrarily selected as a distinctive value when represented in base 16 (the
# common representation base for cluster ids).  48 bits fits exactly into the
# node field of a UUID.
MARKER = 0xAAAAAAAAAAAA


def make_cluster_id(test_type, provider=Providers.UNSPECIFIED,
                    version=VERSION):
    """
    Compose cluster ``UUID`` using test type and storage provider.

    :param test_type: A constant from ``TestTypes`` indicating the intended
        type of test that will use cluster id.
    :param provider: A constant from ``Providers`` indicating the storage
        provider on which cluster will be deployed.
    :param int version: The version to encode into the cluster identifier.  The
        default value is derived from the definition of ``TestTypes`` and
        ``Providers`` and should normally be the value used.
    """
    tmp_uuid = uuid4()
    tagged_cluster_id = UUID(fields=(
        tmp_uuid.time_low, tmp_uuid.time_mid,

        # Special magic markers to identify test clusters.
        #
        # time_hi_version is 16 bits and makes a good place to put the
        # almost-stable version marker.
        version,

        # clock_seq_hi_variant and clock_seq_low are 8 bits each so they make
        # good places to put the two small integers we have to store.
        test_type.value, provider.value,

        # node is 48 bits so it makes a good place to put a big magic marker
        # value to identify this as a special cluster id.
        MARKER,
    ))
    return tagged_cluster_id


def get_cluster_id_information(cluster_id):
    """
    Extract the test type and storage provider information encoded in a cluster
    identifier.

    :param UUID cluster_id: A cluster identifier previously generated and
        encoded using ``make_cluster_id``.

    :raise: ``ValueError`` if ``cluster_id`` does not contain the information.

    :return: A two-tuple of a constant from each of ``TestTypes`` and
        ``Providers``.
    """
    if cluster_id.node != MARKER:
        raise ValueError("Marker not found in cluster_id")
    if cluster_id.time_hi_version != VERSION:
        raise ValueError("Incompatible version ({}) found; expected {}".format(
            cluster_id.time_hi_version, VERSION
        ))

    return (
        TestTypes.lookupByValue(cluster_id.clock_seq_hi_variant),
        Providers.lookupByValue(cluster_id.clock_seq_low),
    )
